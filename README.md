## <center>Домашно ИИ - 8 Puzzle Game</center>



## Описание на проблема

Задачата за 8те блокчета може да бъде разгледана като задача за търсене в пространство от състояния.

Подходът ми към решаването на тази задача е започвайки с дадено състояние, използвайки алгоритемите **A*** и **Best First Search** да намеря *най-добър/ кратък* път (последователност от размествания на плочките) така че да стигна до крайното състояние.

Интересното при тази задача, е че за разлика от тривиалните задачи за търсене, където имаме пространтството от състояния и текущият връх, при тази задача евристичната функция се интересува от общото състояние на цялата съвкупност от плочки, тоест това на какво разстояние от мястото си е дадена плочка не ни носи особено много информация, а по-скоро се интересуваме от това до каква 'степен' са на мясотото си всички блокчета.

Използваните евристики са **Manhattan Distance** и **Count Of Missplaced Tiles**, където **Manhattan Distance** работи като оценява сумата на всички полчки.



## Реализация

За имплементиране на идеята съм използвам **Javascript** тъй като в последствие лесно се визализира работата на алгоритъма.

При търсенето на решението съм използвал **хеширане** на състоянията с цел ограничаване на използваната памет.

Реализирал съм функция, която генерира **единствено решими** състояния.

* ***Забележка*** : Тази задача не винаги има решение. Ако използваме следното представяне на текущо състояние "012345678" (това е крайното записано в такъв вид), то ако **началното състояние** има нечетен брой инверсии в себе си, то тогава задачата няма решение.
* ***Забележка*** : Често начални състояния с **четен брой инверсии**, тоест решими такива се случва алгоритъмът да не успее да намери решение тъй като сложността е експоненциална и много зависи накъде ще тръгне.
* ***Забележка*** : Отностно миналата забележка имам **предположение** защо толкова често алгоритъмът не успява да намери решение (под не успява да намери решение имам предвид в нормално време (1-2 минути)). Обяснение :
  Докато всички върхове, намиращи се във фронтиера имат **различна** евристична оценка, то алгоритъмът върви само в 1 права посока. Дори и да се върне на някое от миналите си състояния, това не е проблем защото върви в "достатъчно добра посока". Проблемът за сериозното забавяне (според мен) е в това, че когато 2 (или повече) върха, имат **еднаква** евристична оценка, то само едно от тези състояния би довело до "най-добро решение", алгоритъмът в последствие продължавайки в дадена посока често ще се "връща" в разклонение започващо от въпросните върхове с **еднаква** евристична оценка, което означава, че той често ще "ходи по грешен път". Съответно колкото повече върхове с еднаква евристична оценка намиращи се във фронтиера се откриват, толкова по-бавен би ставал алгоритъмът.

## Визуализация

Реализирал съм визуализация на алгоритмите с двете евристични функции. За да я видите отворете *visualization.html* файла и натиснете **Randomize Grid**. След това изберете алгоритъм и евристична функция и натиснете **Start**.

***Забележка*** : Поради горните съображения за това, че често задачата няма решение е възможно визуализацията да забие. Ако това се случи затворете страницата и опитайте отново.

